<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <title>Line of sight widget - 4.14</title>

    <link
      rel="stylesheet"
      href="https://js.arcgis.com/4.14/esri/themes/light/main.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js"></script>
    <script src="https://js.arcgis.com/4.14/"></script>

    <script>
      var socket = io('http://localhost:8080');

      require([
        "esri/Map",
        "esri/WebScene",
        "esri/views/SceneView",
        "esri/widgets/LineOfSight",
        "esri/widgets/Expand",
        "esri/geometry/Point",
        "esri/Graphic",
        "esri/layers/GraphicsLayer",
        "esri/tasks/Geoprocessor",
        "esri/tasks/support/LinearUnit",
        "esri/tasks/support/FeatureSet",
        "esri/core/watchUtils"
      ], function(
        Map,
        WebScene,
        SceneView,
        LineOfSightWidget,
        Expand,
        Point,
        Graphic,
        GraphicsLayer,
        Geoprocessor,
        LinearUnit,
        FeatureSet,
        watchUtils
      ) {

        var gpUrl =
          "https://sampleserver6.arcgisonline.com/arcgis/rest/services/Elevation/ESRI_Elevation_World/GPServer/Viewshed";

        var map = new Map({
          basemap: "hybrid",
          ground: "world-elevation"
        });


        //Load a web scene and set it to the map property in a SceneView.
        const scene = new WebScene({
          portalItem: {
            id: "82127fea11d6439abba3318cb93252f7"
          }
        });

        const view = new SceneView({
          map: map,
          container: "viewDiv",
          camera: {
            position: [7.654, 45.919, 5184],
            tilt: 80
          }
        });

        //------------- VIEWSHED ----------------
        var graphicsLayer = new GraphicsLayer();
        map.add(graphicsLayer);


        var markerSymbol = {
          type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
          color: [255, 0, 0],
          outline: {
            // autocasts as new SimpleLineSymbol()
            color: [255, 255, 255],
            width: 2
          }
        };

        //Viewshed fill
        var fillSymbol = {
          type: "simple-fill", // autocasts as new SimpleFillSymbol()
          color: [226, 119, 40, 0.75],
          outline: {
            // autocasts as new SimpleLineSymbol()
            color: [255, 255, 255],
            width: 1
          }
        };

        var gp = new Geoprocessor(gpUrl);
        gp.outSpatialReference = {
          // autocasts as new SpatialReference()
          wkid: 102100
        };

        // view.on("click", computeViewshed);

        view.on("click", sendLocation);

        function drawMarker(location){
          const {longitude, latitude} = location;

          console.log(longitude + ", " + latitude);
          var point = new Point(longitude, latitude);

          var inputGraphic = new Graphic({
            geometry: point,
            symbol: markerSymbol
          });

          graphicsLayer.add(inputGraphic);
        }

        function sendLocation(event){
          const location = {latitude: event.mapPoint.latitude, longitude: event.mapPoint.longitude}
          socket.emit("SEND_LOCATION", location);
          // drawMarker(event.eventPoint);
        }

        function computeViewshed(event) {
          graphicsLayer.removeAll();

          var point = new Point({
            longitude: event.mapPoint.longitude,
            latitude: event.mapPoint.latitude
          });

          var inputGraphic = new Graphic({
            geometry: point,
            symbol: markerSymbol
          });

          graphicsLayer.add(inputGraphic);

          var inputGraphicContainer = [];
          inputGraphicContainer.push(inputGraphic);
          var featureSet = new FeatureSet();
          featureSet.features = inputGraphicContainer;

          var vsDistance = new LinearUnit();
          vsDistance.distance = 3;
          vsDistance.units = "miles";

          var params = {
            Input_Observation_Point: featureSet,
            Viewshed_Distance: vsDistance
          };

          gp.execute(params).then(drawResultData);
        }

        function drawResultData(result) {
          var resultFeatures = result.results[0].value.features;
          // Assign each resulting graphic a symbol
          var viewshedGraphics = resultFeatures.map(function(feature) {
            feature.symbol = fillSymbol;
            return feature;
          });
          //Add the resulting graphics to the graphics layer
          graphicsLayer.addMany(viewshedGraphics);
        }

        //------------ LINE OF SIGHT --------------
        //Initialize the LineOfSight widget
        const lineOfSightWidget = new LineOfSightWidget({
          view: view,
          container: "losWidget"
        });
        const viewModel = lineOfSightWidget.viewModel;

        // watch when observer location changes
        viewModel.watch("observer", function(value) {
          calcLineOfSight();
        });

        // watch when a new target is added or removed
        viewModel.targets.on("change", function(event) {
          event.added.forEach(function(target) {
            calcLineOfSight();
            // for each target watch when the intersection changes
            target.watch("intersectedLocation", calcLineOfSight);
          });
        });

        //init enemy (observer) and targets
        viewModel.observer = new Point({
          latitude: 45.97406769726578,
          longitude: 7.655679901160549,
          z: 3991.9613455347717
        });

        viewModel.targets = [
          createTarget(42.3472, -71.0533),
          createTarget(42.346404707451164, -71.05275212742258, 11.999831333756447)
        ];


        // start the tool to create the line of sight analysis
        viewModel.start();
        // resume the analysis
        watchUtils.whenEqualOnce(viewModel, "state", "creating", function(
          value
        ) {
          viewModel.stop();
        });

        // add an Expand widget to make the menu responsive
        const expand = new Expand({
          expandTooltip: "Expand line of sight widget",
          view: view,
          content: document.getElementById("menu"),
          expanded: true
        });

        view.ui.add(expand, "top-right");

        view.when(function() {
          // allow user to turn the layer with new planned buildings on/off
          // and see how the line of sight analysis changes
          const plannedBuildingsLayer = view.map.layers
            .filter(function(layer) {
              return (
                layer.title === "Boston major projects - MajorProjectsBuildings"
              );
            })
            .getItemAt(0);

          document
            .getElementById("elevationInput")
            .addEventListener("change", updateElevation);

          document
            .getElementById("layerVisibility")
            .addEventListener("change", function(event) {
              plannedBuildingsLayer.visible = event.target.checked;
            });

          document
            .getElementById("updateEnemyBtn")
            .addEventListener("click", function(event) {
              setTargets();
              setEnemy();
            });

            document
            .getElementById("removeMarkers")
            .addEventListener("click", function(event) {
              removeAllMarkers();
            });

        });

        function updateElevation(ev) {
            // Turn ground layers visibility on/off
            map.ground.layers.forEach(function(layer) {
              layer.visible = ev.target.checked;
            });
          }

          function calcLineOfSight() {
          const linesOfSight = []
          view.graphics.removeAll();
          viewModel.targets.forEach((target) => {
            const targetLineOfSight = createTargetLineOfSight(target);
            linesOfSight.push(targetLineOfSight)
          });
          linesOfSight.forEach( line => console.log(line.pos.latitude +", " + line.pos.longitude +", "+ line.pos.z))
          console.log(linesOfSight)
        }

          function setEnemy(lat, lon, z){
            viewModel.observer = new Point({
                latitude: lat || 45.97406529233771,
                longitude: lon || 7.655996720681814,
                z: z || 3965.8866488821805
              });
          }

          function setTargets(lat, lon, z){
            viewModel.targets = [
              createTarget(45.96784892769482, 7.651410484784997, 3253.8066500881687),
              createTarget(45.968743719777265, 7.656008021299391, 3211.2172870952636),
              createTarget(45.96929103821426, 7.658109535605021, 3196.050911039114),
              createTarget(45.96974538523825, 7.660740349503241, 3198.5217655124143),
              createTarget(45.97059670821929, 7.662709157934733, 3204.8219937318936),
              createTarget(45.97152661820499, 7.665263530773247, 3210.3340635905042)
            ]
          }

          function createTarget(lat, lon, z) {
          return {
            location: new Point({
              latitude: lat,
              longitude: lon,
              z: z || 0
            })
          };
        }

          function createTargetLineOfSight(target) {
            const intersection = getLineIntersection(target);
            const isVisible = intersection ? false : true;
          const pos = {latitude:target.location.latitude, longitude:target.location.longitude,  z:target.location.z}
          return {isVisible, pos, intersection}
        }

          function getLineIntersection(target){
            if(target && target.intersectedLocation){
              return {lan: target.intersectedLocation.latitude,
                      lon: target.intersectedLocation.longitude,
                    z: target.intersectedLocation.z}
            }
          }

          function removeAllMarkers() {
            graphicsLayer.removeAll();
          }

          socket.on('SEND_LOCATION', drawMarker);
          socket.on('event', function(data){});
          socket.on('disconnect', function(){});
        });



    </script>

    <style>
      html,
      body,
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }
      #menu {
        padding: 1em;
      }
    </style>
  </head>

  <body>
    <div id="viewDiv">
      <div id="viewDiv">
        <div id="menu" class="esri-widget">
          <div id="elevationDiv" class="esri-widget">
            <label
              >Elevation: <input id="elevationInput" type="checkbox" checked="yes" />
            </label>
          </div>
          <h3>Line of sight analysis</h3>
          <input type="checkbox" id="layerVisibility" checked /><label
            for="layerVisibility"
            >Show development layer</label
          >
          <button id="updateEnemyBtn">update enemy position</button>
          <button id="removeMarkers">RemoveAllMarkers</button>

          <div id="losWidget"></div>
        </div>
      </div>
    </div>
  </body>
</html>
